ans$gameLevel[which(ans$gameLevel == "X2.05")]
head(ans)
[which(ans$gameLevel == "X2.05")
which(ans$gameLevel == "X2.05")
# Relabel improperly labeled levels
ans$gameLevel <- as.character(ans$gameLevel)
which(ans$gameLevel == "X2.05")
ans$gameLevel[ans$gameLevel == "X2.05"]
ans$gameLevel[ans$gameLevel == "X2.05",]
ans[ans$gameLevel == "X2.05",]
ans[ans$gameLevel == "X2.03a",]
ans$gameLevel
ans[ans$gameLevel == "2.05",]
which(ans$gameLevel == "X2.05")
which(ans$gameLevel == "2.05")
ans$gameLevel[which(ans$gameLevel == "2.05")]
ans$gameLevel[ans$gameLevel == "2.05"]
ans$gameLevel[ans$gameLevel == "2.05"] <- "2.03a"
ans$gameLevel[ans$gameLevel == "3.02b"] <- "3.01b"
ans$gameLevel[ans$gameLevel == "3.04b"] <- "3.03b"
ans$gameLevel[ans$gameLevel == "3.04d"] <- "3.03d"
# Create gameLevel labels
level_labels <- ans[, c(5,7,8)]
level_labels <- level_labels[!duplicated(level_labels$gameLevel), ]
level_labels <- level_labels[ order(level_labels[,1]), ]
all_levels <- as.character(level_labels$gameLevel)
core_levels <- c("T1.02a", "T1.03", "T1.05", "T1.04", "T1.07a", "X1.05b", "X1.09a", "X1.08", "X1.07a", "X1.06", "X2.01c", "X2.06b", "X2.05a", "X2.04b", "X2.03a", "T3.01a", "X3.01b", "X3.03b", "X3.03d", "T4.01a", "T4.01b", "T4.02", "T4.03a", "X4.07b", "X4.1", "X4.16", "X4.17", "X4.13")
# Select 1st attempts only
ans <- ans[which(ans$attempt_count == 1), ]
ans <- ans[ order(ans[,2], ans[,5]), ] # 8524 rows
# Find duplicate uid/game level
ans <- ans[!duplicated(ans[c("userId","gameLevel")]), ] # Remove duplicates (8407 rows)
# View gameLevel sequences
ans[order(ans[,2], ans[,1]), c("userId", "clientTimeStamp", "gameLevel", "success")]
# Pivot answer submissions to make response vectors
resp <- ans[, c(2,5,9)]
resp <- dcast(resp, userId ~ gameLevel, fill = 3, fun.aggregate = mean)
head(resp)
# Replace non-attempts with NA and keep 0 for first attempt fails
resp <- data.frame(lapply(resp, function(y) gsub("^3$", NA, y)))
sapply(resp, function(y) sum(length(which(!is.na(y))))) # Attempt counts
head(resp)
# Pivot answer submissions to make response vectors
resp <- ans[, c(2,5,9)]
resp <- dcast(resp, userId ~ gameLevel, fill = 3, fun.aggregate = mean, check.names = FALSE)
# Replace non-attempts with NA and keep 0 for first attempt fails
resp <- data.frame(lapply(resp, function(y) gsub("^3$", NA, y)), check.names = FALSE)
sapply(resp, function(y) sum(length(which(!is.na(y))))) # Attempt counts
# Pivot answer submissions to make response vectors
resp <- ans[, c(2,5,9)]
resp <- dcast(resp, userId ~ gameLevel, fill = 3, fun.aggregate = mean)
# Replace non-attempts with NA and keep 0 for first attempt fails
resp <- data.frame(lapply(resp, function(y) gsub("^3$", NA, y)), check.names = FALSE)
sapply(resp, function(y) sum(length(which(!is.na(y))))) # Attempt counts
# Remove hand-feeding challenges T2.01 T1.01 T2.01.REPLACE (handfeed 3 baby ram)
resp <- resp[ , setdiff(names(resp), c("T2.01", "T1.01", "T2.01.REPLACE"))]
resp <- data.frame(lapply(resp, function(x) as.numeric(as.character(x))))
head(resp)
# Pivot answer submissions to make response vectors
resp <- ans[, c(2,5,9)]
resp <- dcast(resp, userId ~ gameLevel, fill = 3, fun.aggregate = mean)
# Replace non-attempts with NA and keep 0 for first attempt fails
resp <- data.frame(lapply(resp, function(y) gsub("^3$", NA, y)), check.names = FALSE)
sapply(resp, function(y) sum(length(which(!is.na(y))))) # Attempt counts
# Remove hand-feeding challenges T2.01 T1.01 T2.01.REPLACE (handfeed 3 baby ram)
resp <- resp[ , setdiff(names(resp), c("T2.01", "T1.01", "T2.01.REPLACE"))]
resp <- data.frame(lapply(resp, function(x) as.numeric(as.character(x))), check.names = FALSE)
sapply(resp, function(y) sum(length(which(!is.na(y))))) # Attempt counts
core <- resp[, c(1, core_levels)]
core_levels <- c("T1.02a", "T1.03", "T1.05", "T1.04", "T1.07a", "1.05b", "1.09a", "1.08", "1.07a", "1.06", "2.01c", "2.06b", "2.05a", "2.04b", "X2.03a", "T3.01a", "3.01b", "3.03b", "3.03d", "T4.01a", "T4.01b", "T4.02", "T4.03a", "4.07b", "4.1", "4.16", "4.17", "4.13")
core <- resp[, c(1, core_levels)]
core_levels <- c("T1.02a", "T1.03", "T1.05", "T1.04", "T1.07a", "1.05b", "1.09a", "1.08", "1.07a", "1.06", "2.01c", "2.06b", "2.05a", "2.04b", "2.03a", "T3.01a", "3.01b", "3.03b", "3.03d", "T4.01a", "T4.01b", "T4.02", "T4.03a", "4.07b", "4.1", "4.16", "4.17", "4.13")
core <- resp[, c(1, core_levels)]
test <- resp[, c("T1.02a", "T1.03", "T1.05", "T1.04")] # , "T1.07a", "1.05b", "1.09a", "1.08", "1.07a", "1.06", "2.01c", "2.06b", "2.05a", "2.04b", "2.03a", "T3.01a", "3.01b", "3.03b", "3.03d", "T4.01a", "T4.01b", "T4.02", "T4.03a", "4.07b", "4.1", "4.16", "4.17", "4.13"
test <- resp[, c("T1.07a", "1.05b", "1.09a", "1.08")] # , , "1.07a", "1.06", "2.01c", "2.06b", "2.05a", "2.04b", "2.03a", "T3.01a", "3.01b", "3.03b", "3.03d", "T4.01a", "T4.01b", "T4.02", "T4.03a", "4.07b", "4.1", "4.16", "4.17", "4.13"
test <- resp[, c("1.07a", "1.06", "2.01c", "2.06b")] # , , , "2.05a", "2.04b", "2.03a", "T3.01a", "3.01b", "3.03b", "3.03d", "T4.01a", "T4.01b", "T4.02", "T4.03a", "4.07b", "4.1", "4.16", "4.17", "4.13"
test <- resp[, c( "2.05a", "2.04b", "2.03a", "T3.01a", "3.01b", "3.03b", "3.03d", "T4.01a")] # , , ,, "T4.01b", "T4.02", "T4.03a", "4.07b", "4.1", "4.16", "4.17", "4.13"
test <- resp[, c( "T4.01b", "T4.02", "T4.03a", "4.07b", "4.1", "4.16", "4.17", "4.13")] # , , ,,
test <- resp[, c(1, "T4.01b", "T4.02", "T4.03a", "4.07b", "4.1", "4.16", "4.17", "4.13")] # , , ,,
head(resp)
core <- resp[, c("userId", core_levels)]
core1 <- resp[, c("userId", "T1.02a", "T1.03", "T1.05", "T1.04", "T1.07a", "1.05b", "1.09a", "1.08", "1.07a", "1.06")]
core2 <- resp[, c("userId", "2.01c", "2.06b", "2.05a", "2.04b", "2.03a")]
core3 <- resp[, c("userId", "T3.01a", "3.01b", "3.03b", "3.03d")]
core4 <- resp[, c("userId", "T4.01a", "T4.01b", "T4.02", "T4.03a", "4.07b", "4.1", "4.16", "4.17", "4.13")]
resp %>% select(core_levels) %>% rowSums(na.rm=TRUE) -> resp$coreTot
which(names(resp) %in% core_levels
)
resp %>% select(which(names(resp) %in% core_levels)) %>% rowSums(na.rm=TRUE) -> resp$coreTot
core1_levels <- c("userId", "T1.02a", "T1.03", "T1.05", "T1.04", "T1.07a", "1.05b", "1.09a", "1.08", "1.07a", "1.06")
core2_levels <- c("userId", "2.01c", "2.06b", "2.05a", "2.04b", "2.03a")
core3_levels <- c("userId", "T3.01a", "3.01b", "3.03b", "3.03d")
core4_levels <- c("userId", "T4.01a", "T4.01b", "T4.02", "T4.03a", "4.07b", "4.1", "4.16", "4.17", "4.13")
resp %>% select(which(names(resp) %in% core1_levels)) %>% rowSums(na.rm=TRUE) -> resp$core1Tot
resp %>% select(which(names(resp) %in% core2_levels)) %>% rowSums(na.rm=TRUE) -> resp$core2Tot
resp %>% select(which(names(resp) %in% core3_levels)) %>% rowSums(na.rm=TRUE) -> resp$core3Tot
resp %>% select(which(names(resp) %in% core4_levels)) %>% rowSums(na.rm=TRUE) -> resp$core4Tot
head(resp)
core1_levels <- c("T1.02a", "T1.03", "T1.05", "T1.04", "T1.07a", "1.05b", "1.09a", "1.08", "1.07a", "1.06")
core2_levels <- c("2.01c", "2.06b", "2.05a", "2.04b", "2.03a")
core3_levels <- c("T3.01a", "3.01b", "3.03b", "3.03d")
core4_levels <- c("T4.01a", "T4.01b", "T4.02", "T4.03a", "4.07b", "4.1", "4.16", "4.17", "4.13")
resp %>% select(which(names(resp) %in% core1_levels)) %>% rowSums(na.rm=TRUE) -> resp$core1Tot
head(resp)
resp %>% select(which(names(resp) %in% core2_levels)) %>% rowSums(na.rm=TRUE) -> resp$core2Tot
resp %>% select(which(names(resp) %in% core3_levels)) %>% rowSums(na.rm=TRUE) -> resp$core3Tot
resp %>% select(which(names(resp) %in% core4_levels)) %>% rowSums(na.rm=TRUE) -> resp$core4Tot
head(resp)
resp %>% select(2:ncol(resp)) %>% rowSums(na.rm=TRUE) -> resp$respTot
head(resp)
# Pivot answer submissions to make response vectors
resp <- ans[, c(2,5,9)]
resp <- dcast(resp, userId ~ gameLevel, fill = 3, fun.aggregate = mean)
# Replace non-attempts with NA and keep 0 for first attempt fails
resp <- data.frame(lapply(resp, function(y) gsub("^3$", NA, y)), check.names = FALSE)
sapply(resp, function(y) sum(length(which(!is.na(y))))) # Attempt counts
# Remove hand-feeding challenges T2.01 T1.01 T2.01.REPLACE (handfeed 3 baby ram)
resp <- resp[ , setdiff(names(resp), c("T2.01", "T1.01", "T2.01.REPLACE"))]
resp <- data.frame(lapply(resp, function(x) as.numeric(as.character(x))), check.names = FALSE)
resp %>% select(2:ncol(resp)) %>% rowSums(na.rm=TRUE) -> resp$respTot
resp %>% select(which(names(resp) %in% core_levels)) %>% rowSums(na.rm=TRUE) -> resp$coreTot
resp %>% select(which(names(resp) %in% core1_levels)) %>% rowSums(na.rm=TRUE) -> resp$core1Tot
resp %>% select(which(names(resp) %in% core2_levels)) %>% rowSums(na.rm=TRUE) -> resp$core2Tot
resp %>% select(which(names(resp) %in% core3_levels)) %>% rowSums(na.rm=TRUE) -> resp$core3Tot
resp %>% select(which(names(resp) %in% core4_levels)) %>% rowSums(na.rm=TRUE) -> resp$core4Tot
head(resp)
dim(resp)
respTotals <- resp[, c(1,61:66)]
# Load in pr/po scores and ability estimates (thetas)
theta <- read.table("./Data/prpotheta.csv", fill = TRUE, header = TRUE, sep = ",")
# Merge pr/po/resp totals by UID
df <- merge(theta, respTotals, by = "uid")
head(respTotals)
names(respTotals)[1]
names(respTotals)[1] <- "uid"
# Merge pr/po/resp totals by UID
df <- merge(theta, respTotals, by = "uid")
df <- cbind(df, diff=df$po_est-df$pr_est) # add column with difference between ability estimates (po - pr)
summary(df)
num <- df[4:14]
# Pearson correlation
cor(num,num) # pr/po data is positively correlated. Game data is not correlated to survey data
library(tidyverse)
library(reshape2)
# Load in game answer submissions
ans <- read.table("./Data/submit_answer.csv", fill = TRUE, header = TRUE, sep = ",")
# Relabel improperly labeled levels
ans$gameLevel <- as.character(ans$gameLevel)
ans$gameLevel[ans$gameLevel == "2.05"] <- "2.03a"
ans$gameLevel[ans$gameLevel == "3.02b"] <- "3.01b"
ans$gameLevel[ans$gameLevel == "3.04b"] <- "3.03b"
ans$gameLevel[ans$gameLevel == "3.04d"] <- "3.03d"
# Create gameLevel labels
level_labels <- ans[, c(5,7,8)]
level_labels <- level_labels[!duplicated(level_labels$gameLevel), ]
level_labels <- level_labels[ order(level_labels[,1]), ]
all_levels <- as.character(level_labels$gameLevel)
core_levels <- c("T1.02a", "T1.03", "T1.05", "T1.04", "T1.07a", "1.05b", "1.09a", "1.08", "1.07a", "1.06", "2.01c", "2.06b", "2.05a", "2.04b", "2.03a", "T3.01a", "3.01b", "3.03b", "3.03d", "T4.01a", "T4.01b", "T4.02", "T4.03a", "4.07b", "4.1", "4.16", "4.17", "4.13")
core1_levels <- c("T1.02a", "T1.03", "T1.05", "T1.04", "T1.07a", "1.05b", "1.09a", "1.08", "1.07a", "1.06")
core2_levels <- c("2.01c", "2.06b", "2.05a", "2.04b", "2.03a")
core3_levels <- c("T3.01a", "3.01b", "3.03b", "3.03d")
core4_levels <- c("T4.01a", "T4.01b", "T4.02", "T4.03a", "4.07b", "4.1", "4.16", "4.17", "4.13")
ans <- ans[which(ans$attempt_count == 1), ]
ans <- ans[ order(ans[,2], ans[,5]), ] # 8524 rows
# Find duplicate uid/game level
ans <- ans[!duplicated(ans[c("userId","gameLevel")]), ] # Remove duplicates (8407 rows)
# View gameLevel sequences
ans[order(ans[
# View gameLevel sequences
ans[order(ans[,2], ans[,1]), c("userId", "clientTimeStamp", "gameLevel", "success")]
# Pivot answer submissions to make response vectors
resp <- ans[, c(2,5,9)]
resp <- dcast(resp, userId ~ gameLevel, fill = 3, fun.aggregate = mean)
# Replace non-attempts with NA and keep 0 for first attempt fails
resp <- data.frame(lapply(resp, function(y) gsub("^3$", NA, y)), check.names = FALSE)
sapply(resp, function(y) sum(length(which(!is.na(y))))) # Attempt counts
# Remove hand-feeding challenges T2.01 T1.01 T2.01.REPLACE (handfeed 3 baby ram)
resp <- resp[ , setdiff(names(resp), c("T2.01", "T1.01", "T2.01.REPLACE"))]
resp <- data.frame(lapply(resp, function(x) as.numeric(as.character(x))), check.names = FALSE)
resp %>% select(2:ncol(resp)) %>% rowSums(na.rm=TRUE) -> resp$respTot
resp %>% select(which(names(resp) %in% core_levels)) %>% rowSums(na.rm=TRUE) -> resp$coreTot
resp %>% select(which(names(resp) %in% core1_levels)) %>% rowSums(na.rm=TRUE) -> resp$core1Tot
resp %>% select(which(names(resp) %in% core2_levels)) %>% rowSums(na.rm=TRUE) -> resp$core2Tot
resp %>% select(which(names(resp) %in% core3_levels)) %>% rowSums(na.rm=TRUE) -> resp$core3Tot
resp %>% select(which(names(resp) %in% core4_levels)) %>% rowSums(na.rm=TRUE) -> resp$core4Tot
mutate(resp, core23Tot = core2Tot + core3Tot)
resp <- mutate(resp, core23Tot = core2Tot + core3Tot)
resp <- mutate(resp, core24Tot = core2Tot + core3Tot + core4Tot)
resp <- mutate(resp, core34Tot = core3Tot + cor43Tot)
resp <- mutate(resp, core34Tot = core3Tot + cor4Tot)
resp <- mutate(resp, core34Tot = core3Tot + core4Tot)
respTotals <- resp[, c(1,61:69)]
names(respTotals)[1] <- "uid"
# Load in pr/po scores and ability estimates (thetas)
theta <- read.table("./Data/prpotheta.csv", fill = TRUE, header = TRUE, sep = ",")
# Merge pr/po/resp totals by UID
df <- merge(theta, respTotals, by = "uid")
df <- cbind(df, diff=df$po_est-df$pr_est) # add column with difference between ability estimates (po - pr)
summary(df)
num <- df[4:14]
# Pearson correlation
cor(num,num) # pr/po data is positively correlated. Game data is not correlated to survey data
head(df)
num <- df[4:17]
# Pearson correlation
cor(num,num) # pr/po data is positively correlated. Game data is not correlated to survey data
# Pearson correlation
cor(num,num) # pr/po data is positively correlated. Game data is not correlated to survey data
# Pearson correlation
cor(num,num) # pr/po data is positively correlated.
# Correlation between in-game performance and pr/po ability estimates
gameperf <- df$Grand.Total
thetapo <- df$po_est
cor(gameperf,thetapo) # 0.1735607, slight positive correlation
head(df)
# Correlation between in-game performance and pr/po ability estimates
gameperf <- df$respTot
cor(gameperf,thetapo) # 0.1735607, slight positive correlation
# Load in game response vectors from Seth's data cleaning
resp_val <- read.table("./Data/gameRespVec.csv", fill = TRUE, header = TRUE, sep = ",")
respTot_val <- resp_val[, c(1,ncol(resp_val))] # Number of correct 1st attempts per player
df_val <- merge(theta, respTot_val, by = "uid")
head(df_val)
num_val <- df_val[4:8]
# Pearson correlation
cor(num_val,num_val) # pr/po data is positively correlated.
dim(df_val)
dim(df)
cor(gameperf,thetapo)
# 1:1 Plot of Game Performance vs Post Ability Estimates
plot(gameperf, thetapo,
pch = 16,
xlab="Game Performance",
ylab="Ability Difference")
plot(gameperf, diff,
pch = 16,
xlab="Game Performance",
ylab="Ability Difference")
# 1:1 Plot of Game Performance vs Post Ability Estimates
plot(gameperf, thetapo,
pch = 16,
xlab="Game Performance",
ylab="Ability Post")
head(df)
diff <- df$diff
plot(gameperf, diff,
pch = 16,
xlab="Game Performance",
ylab="Ability Difference")
plot(df$core24Tot, df$diff,
pch = 16,
xlab="Game Performance",
ylab="Ability Difference")
plot(df$core24Tot, thetapo,
pch = 16,
xlab="Core Levels 2-4 Performance",
ylab="Ability Post")
abline(-4,2/5, col="blue", lwd=2)
plot(df$core24Tot, thetapo,
pch = 16,
xlab="Core Levels 2-4 Performance",
ylab="Ability Post")
abline(-4,2/3, col="blue", lwd=2)
scatter <- qplot(gameperf, diff)  +
scale_x_continuous(limits=c(min(gameperf),max(gameperf))) +
scale_y_continuous(limits=c(min(diff),max(diff))) +
geom_rug(col=rgb(.5,0,0,alpha=.2))
scatter
kdp <- ggplot(df, aes(x = df$respTot, y = df$po_est)) +
geom_point(aes(colour = df$tchr)) +
xlim(-2, 24) +
ylim(-6, 6)
kdp + geom_density_2d() # aes(colour = df$tchr)
kdp + geom_density_2d(aes(colour = df$tchr)) # aes(colour = df$tchr)
core24 <- df$core24Tot
scatter <- qplot(core24, diff)  +
scale_x_continuous(limits=c(min(gameperf),max(gameperf))) +
scale_y_continuous(limits=c(min(diff),max(diff))) +
geom_rug(col=rgb(.5,0,0,alpha=.2))
scatter
scatter <- qplot(core24, diff)  +
scale_x_continuous(limits=c(min(core24),max(core24))) +
scale_y_continuous(limits=c(min(diff),max(diff))) +
geom_rug(col=rgb(.5,0,0,alpha=.2))
scatter
scatter <- qplot(core24, thetapo)  +
scale_x_continuous(limits=c(min(core24),max(core24))) +
scale_y_continuous(limits=c(min(thetapo),max(thetapo))) +
geom_rug(col=rgb(.5,0,0,alpha=.2))
scatter
head(resp)
# l1 subtotal if challenge starts with T1. or 1.
l1 <- resp[,c(1:16,49:54)]
head(l1)
l1[,2:ncol(l1)] <- sapply(l1[,2:ncol(l1)], function(y) as.numeric(as.character(unlist(y))))
l1 <- as.data.frame(l1)
l1$l1Tot <- rowSums(l1[,2:ncol(l1)], na.rm = TRUE)
head(l1)
head(df)
l1Tot <- l1[,c(1,ncol(l1))]
df <- merge(df, l1Tot, by='uid')
head(l1)
names(l1Tot)[1] <- "uid"
df <- merge(df, l1Tot, by='uid')
head(df)
names(resp)[1] <- "uid"
# l2 subtotal if challenge starts with T2. or 2.
l2 <- resp[,c(1,17:29)]
l2[,2:ncol(l2)] <- sapply(l2[,2:ncol(l2)], function(y) as.numeric(as.character(unlist(y))))
l2 <- as.data.frame(l2)
l2$l2Tot <- rowSums(l2[,2:ncol(l2)], na.rm = TRUE)
l2Tot <- l2[,c(1,ncol(l2))]
df <- merge(df, l2Tot, by='uid')
# l3 subtotal if challenge starts with T3. or 3.
l3 <- resp[,c(1,30:35,56)]
head(l2)
head(resp)
# Remove hand-feeding challenges T2.01 T1.01 T2.01.REPLACE (handfeed 3 baby ram)
resp <- resp[ , setdiff(names(resp), c("T2.01", "T1.01", "T2.01-REPLACE"))]
head(resp)
non_tutorial_core <- c("1.05b", "1.09a", "1.08", "1.07a", "1.06", "2.01c", "2.06b", "2.05a", "2.04b", "2.03a", "3.01b", "3.03b", "3.03d", "4.07b", "4.1", "4.16", "4.17", "4.13")
tutorial_core <- c("T1.02a", "T1.03", "T1.05", "T1.04", "T1.07a", "T3.01a", "T4.01a", "T4.01b", "T4.02", "T4.03a")
review1_levels <- c("1.01a", "1.01b", "1.02b", "1.02c", "1.03a", "1.03c", "1.04a", "1.05a", "1.05c", "1.07b")
review2_levels <- c("2.01a", "2.01b", "2.02a", "2.02c", "2.03b", "2.04a", "2.06a")
review3_levels <- c("3.01a", "3.01c", "3.03a")
review4_levels <- c("4.02a", "4.03a", "4.03b", "4.03c", "4.04a", "4.07b", "4.08", "4.11", "4.15")
review_levels <- c("1.01a", "1.01b", "1.02b", "1.02c", "1.03a", "1.03c", "1.04a", "1.05a", "1.05c", "1.07b", "2.01a", "2.01b", "2.02a", "2.02c", "2.03b", "2.04a", "2.06a", "3.01a", "3.01c", "3.03a", "4.02a", "4.03a", "4.03b", "4.03c", "4.04a", "4.07b", "4.08", "4.11", "4.15")
non_tutorial_core <- c("1.05b", "1.09a", "1.08", "1.07a", "1.06", "2.01c", "2.06b", "2.05a", "2.04b", "2.03a", "3.01b", "3.03b", "3.03d", "4.07b", "4.1", "4.16", "4.17", "4.13")
tutorial_core <- c("T1.02a", "T1.03", "T1.05", "T1.04", "T1.07a", "T3.01a", "T4.01a", "T4.01b", "T4.02", "T4.03a")
# Library Imports
library(tidyverse)
library(reshape2)
# Load in game answer submissions
ans <- read.table("./Data/submit_answer.csv", fill = TRUE, header = TRUE, sep = ",")
# Relabel improperly labeled levels
ans$gameLevel <- as.character(ans$gameLevel)
ans$gameLevel[ans$gameLevel == "2.05"] <- "2.03a"
ans$gameLevel[ans$gameLevel == "3.02b"] <- "3.01b"
ans$gameLevel[ans$gameLevel == "3.04b"] <- "3.03b"
ans$gameLevel[ans$gameLevel == "3.04d"] <- "3.03d"
# Create gameLevel labels
level_labels <- ans[, c(5,7,8)]
level_labels <- level_labels[!duplicated(level_labels$gameLevel), ]
level_labels <- level_labels[ order(level_labels[,1]), ]
all_levels <- as.character(level_labels$gameLevel)
core_levels <- c("T1.02a", "T1.03", "T1.05", "T1.04", "T1.07a", "1.05b", "1.09a", "1.08", "1.07a", "1.06", "2.01c", "2.06b", "2.05a", "2.04b", "2.03a", "T3.01a", "3.01b", "3.03b", "3.03d", "T4.01a", "T4.01b", "T4.02", "T4.03a", "4.07b", "4.1", "4.16", "4.17", "4.13")
review_levels <- c("1.01a", "1.01b", "1.02b", "1.02c", "1.03a", "1.03c", "1.04a", "1.05a", "1.05c", "1.07b", "2.01a", "2.01b", "2.02a", "2.02c", "2.03b", "2.04a", "2.06a", "3.01a", "3.01c", "3.03a", "4.02a", "4.03a", "4.03b", "4.03c", "4.04a", "4.07b", "4.08", "4.11", "4.15")
non_tutorial_core <- c("1.05b", "1.09a", "1.08", "1.07a", "1.06", "2.01c", "2.06b", "2.05a", "2.04b", "2.03a", "3.01b", "3.03b", "3.03d", "4.07b", "4.1", "4.16", "4.17", "4.13")
tutorial_core <- c("T1.02a", "T1.03", "T1.05", "T1.04", "T1.07a", "T3.01a", "T4.01a", "T4.01b", "T4.02", "T4.03a")
core1_levels <- c("T1.02a", "T1.03", "T1.05", "T1.04", "T1.07a", "1.05b", "1.09a", "1.08", "1.07a", "1.06")
review1_levels <- c("1.01a", "1.01b", "1.02b", "1.02c", "1.03a", "1.03c", "1.04a", "1.05a", "1.05c", "1.07b")
core2_levels <- c("2.01c", "2.06b", "2.05a", "2.04b", "2.03a")
review2_levels <- c("2.01a", "2.01b", "2.02a", "2.02c", "2.03b", "2.04a", "2.06a")
core3_levels <- c("T3.01a", "3.01b", "3.03b", "3.03d")
review3_levels <- c("3.01a", "3.01c", "3.03a")
core4_levels <- c("T4.01a", "T4.01b", "T4.02", "T4.03a", "4.07b", "4.1", "4.16", "4.17", "4.13")
review4_levels <- c("4.02a", "4.03a", "4.03b", "4.03c", "4.04a", "4.07b", "4.08", "4.11", "4.15")
# Select 1st attempts only
ans <- ans[which(ans$attempt_count == 1), ]
ans <- ans[ order(ans[,2], ans[,5]), ] # 8524 rows
# Find duplicate uid/game level
ans <- ans[!duplicated(ans[c("userId","gameLevel")]), ] # Remove duplicates (8407 rows)
# View gameLevel sequences
ans[order(ans[,2], ans[,1]), c("userId", "clientTimeStamp", "gameLevel", "success")]
# Pivot answer submissions to make response vectors
resp <- ans[, c(2,5,9)]
resp <- dcast(resp, userId ~ gameLevel, fill = 3, fun.aggregate = mean)
# Replace non-attempts with NA and keep 0 for first attempt fails
resp <- data.frame(lapply(resp, function(y) gsub("^3$", NA, y)), check.names = FALSE)
sapply(resp, function(y) sum(length(which(!is.na(y))))) # Attempt counts
# Remove hand-feeding challenges T2.01 T1.01 T2.01.REPLACE (adult ram, baby ram, 3 baby ram)
resp <- resp[ , setdiff(names(resp), c("T2.01", "T1.01", "T2.01-REPLACE"))]
resp <- data.frame(lapply(resp, function(x) as.numeric(as.character(x))), check.names = FALSE)
# Find total score across game data response vectors
resp %>% select(2:ncol(resp)) %>% rowSums(na.rm=TRUE) -> resp$respTot
# Since game is teaching along the way, subset game performance into levels {L1, L2, L3, L4}
resp %>% select(which(names(resp) %in% c(review1_levels, core1_levels))) %>% rowSums(na.rm=TRUE) -> resp$L1Tot
resp %>% select(which(names(resp) %in% c(review2_levels, core2_levels))) %>% rowSums(na.rm=TRUE) -> resp$L2Tot
resp %>% select(which(names(resp) %in% c(review3_levels, core3_levels))) %>% rowSums(na.rm=TRUE) -> resp$L3Tot
resp %>% select(which(names(resp) %in% c(review4_levels, core4_levels))) %>% rowSums(na.rm=TRUE) -> resp$L4Tot
resp <- mutate(resp, L23Tot = L2Tot + L3Tot)
resp <- mutate(resp, L24Tot = L2Tot + L3Tot + L4Tot)
resp <- mutate(resp, L34Tot = L3Tot + L4Tot)
# Since review levels are not seen by all players, subset into core levels {core, core1, core2, core3, core4}
resp %>% select(which(names(resp) %in% core_levels)) %>% rowSums(na.rm=TRUE) -> resp$coreTot
resp %>% select(which(names(resp) %in% core1_levels)) %>% rowSums(na.rm=TRUE) -> resp$core1Tot
resp %>% select(which(names(resp) %in% core2_levels)) %>% rowSums(na.rm=TRUE) -> resp$core2Tot
resp %>% select(which(names(resp) %in% core3_levels)) %>% rowSums(na.rm=TRUE) -> resp$core3Tot
resp %>% select(which(names(resp) %in% core4_levels)) %>% rowSums(na.rm=TRUE) -> resp$core4Tot
resp <- mutate(resp, core23Tot = core2Tot + core3Tot)
resp <- mutate(resp, core24Tot = core2Tot + core3Tot + core4Tot)
resp <- mutate(resp, core34Tot = core3Tot + core4Tot)
# to see how review levels compare, look at them independently
resp %>% select(which(names(resp) %in% review_levels)) %>% rowSums(na.rm=TRUE) -> resp$reviewTot
resp %>% select(which(names(resp) %in% review1_levels)) %>% rowSums(na.rm=TRUE) -> resp$review1Tot
resp %>% select(which(names(resp) %in% review2_levels)) %>% rowSums(na.rm=TRUE) -> resp$review2Tot
resp %>% select(which(names(resp) %in% review3_levels)) %>% rowSums(na.rm=TRUE) -> resp$review3Tot
resp %>% select(which(names(resp) %in% review4_levels)) %>% rowSums(na.rm=TRUE) -> resp$review4Tot
resp <- mutate(resp, review23Tot = review2Tot + review3Tot)
resp <- mutate(resp, review24Tot = review2Tot + review3Tot + review4Tot)
resp <- mutate(resp, review34Tot = review3Tot + review4Tot)
# Check tutorial vs non-tutorial levels
resp %>% select(which(names(resp) %in% non_tutorial_core)) %>% rowSums(na.rm=TRUE) -> resp$nonTutorialCoreTot
resp %>% select(which(names(resp) %in% tutorial_core)) %>% rowSums(na.rm=TRUE) -> resp$tutorialCoreTot
names(resp)[1] <- "uid"
head(resp)
respTotals <- resp[, c(1,61:86)]
respTotals <- resp[, c(1,60:85)]
head(respTotals)
# Load in pr/po scores and ability estimates (thetas)
theta <- read.table("./Data/prpotheta.csv", fill = TRUE, header = TRUE, sep = ",")
# Merge pr/po/resp totals by UID
df <- merge(theta, respTotals, by = "uid")
df <- cbind(df, diff=df$po_est-df$pr_est) # add column with difference between ability estimates (po - pr)
summary(df)
num <- df[4:nrow(df)]
num <- df[4:nrow(df),]
# Pearson correlation
cor(num,num) # pr/po data is positively correlated.
str(df)
str(num)
num <- df[, 4:nrow(df)]
num <- df[, 4:ncol(df)]
str(num)
dim(num)
# Pearson correlation
cor(num,num) # pr/po data is positively correlated.
respTotals <- resp[, c("uid", "respTot", "coreTot", "reviewTot", "nonTutorialCoreTot", "tutorialCoreTot")]
respLevels <- resp[, c("uid", "L1Tot", "core1Tot", "review1Tot", "L2Tot", "core2Tot","review2Tot", "L3Tot", "core3Tot", "review3Tot", "L4Tot", "core4Tot", "review4Tot")]
respCombos <- resp[, c("uid", "L23Tot", "core23Tot", "review23Tot", "L24Tot", "core24Tot","review24Tot", "L34Tot", "core34Tot", "review34Tot")]
# Merge pr/po/resp totals by UID
totals <- merge(theta, respTotals, by = "uid")
levels <- merge(theta, respLevels, by = "uid")
combos <- merge(theta, respCombos, by = "uid")
head(totals)
tot <- totals[, 4:ncol(df)]
lev <- levels[, 4:ncol(df)]
tot <- totals[, 4:ncol(totals)]
lev <- levels[, 4:ncol(levels)]
com <- combos[, 4:ncol(combos)]
# Pearson correlation
cor(tot,tot) # pr/po data is positively correlated.
# Pearson correlation
cor(lev,lev) # pr/po data is positively correlated.
# Pearson correlation
cor(com,com) # pr/po data is positively correlated.
# Pearson correlation
cor(com,com)[,c(1:4)] # pr/po data is positively correlated.
all_levels
setdiff(all_levels, c("T2.01", "T1.01", "T2.01-REPLACE"))
# Remove hand-feeding challenges T2.01 T1.01 T2.01.REPLACE (adult ram, baby ram, 3 baby ram)
all_levels <- setdiff(all_levels, c("T2.01", "T1.01", "T2.01-REPLACE"))
# Find total score across game data response vectors (respTotals)
resp %>%select(which(names(resp) %in% all_levels)) %>% rowSums(na.rm=TRUE) -> resp$allTot
respTotals <- resp[, c("uid", "allTot", "coreTot", "reviewTot", "nonTutorialCoreTot", "tutorialCoreTot")]
# Merge pr/po/resp totals by UID
totals <- merge(theta, respTotals, by = "uid")
tot <- totals[, 4:ncol(totals)] # Largest positive correlation with nonTutorial levels -> nonTutorialCoreTot 0.27711696 0.2877823 0.28520689 0.26184614
# Pearson correlation
cor(tot,tot)[,c(1:4)] # pr/po data is positively correlated.
cor(lev,lev)[,c(1:4)]
cor(com,com)[,c(1:4)]
head(theta)
theta <- cbind(theta, diff=theta$po_est-theta$pr_est) # add column with difference between ability estimates (po - pr)
head(theta)
# Merge pr/po/resp totals by UID
totals <- merge(theta, respTotals, by = "uid")
levels <- merge(theta, respLevels, by = "uid")
combos <- merge(theta, respCombos, by = "uid")
head(totals)
tot <- totals[, 4:ncol(totals)] # Largest positive correlation with nonTutorial levels -> nonTutorialCoreTot 0.27711696 0.2877823 0.28520689 0.26184614
lev <- levels[, 4:ncol(levels)] # first review levels negatively correlate with survey performance review1Tot -0.30359333 -0.28300671 -0.28809288
com <- combos[, 4:ncol(combos)]
# Pearson correlation
cor(tot,tot)[,c(1:5)]
lev <- levels[, 4:ncol(levels)] # first review levels negatively correlate with survey performance review1Tot -0.30359333 -0.28300671 -0.28809288
cor(lev,lev)[,c(1:5)]
cor(com,com)[,c(1:5)]
plot(core24, thetapo, # Since core24Tot has a better correlation with thetapo, may be a more telling measure
pch = 16,
xlab="Core Levels 2-4 Performance",
ylab="Ability Post")
# Correlation between in-game performance and pr/po ability estimates
gameperf <- totals$respTot
thetapo <- totals$po_est
diff <- totals$diff
core24 <- combos$core24Tot
cor(gameperf,thetapo) # 0.1535502 slight positive correlation
str(totals)
# Correlation between in-game performance and pr/po ability estimates
gameperf <- totals$allTot
thetapo <- totals$po_est
diff <- totals$diff
core24 <- combos$core24Tot
cor(gameperf,thetapo) # 0.1535502 slight positive correlation
# 1:1 Plot of Game Performance vs Post Ability Estimates
plot(gameperf, thetapo,
pch = 16,
xlab="Game Performance",
ylab="Ability Post")
abline(-4,2/5, col="blue", lwd=2)
plot(core24, thetapo, # Since core24Tot has a better correlation with thetapo, may be a more telling measure
pch = 16,
xlab="Core Levels 2-4 Performance",
ylab="Ability Post")
abline(-4,2/3, col="blue", lwd=2)
scatter <- qplot(core24, thetapo)  +
scale_x_continuous(limits=c(min(core24),max(core24))) +
scale_y_continuous(limits=c(min(thetapo),max(thetapo))) +
geom_rug(col=rgb(.5,0,0,alpha=.2))
scatter
abline(-4,2/3, col="blue", lwd=2)
